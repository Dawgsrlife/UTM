\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[noend]{algpseudocode}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\geometry{margin=1in}

% Configure listings for Python
\lstset{
	language=Python,
	basicstyle=\ttfamily\small,
	keywordstyle=\color{blue},
	stringstyle=\color{red},
	commentstyle=\color{gray},
	showstringspaces=false,
	breaklines=true,
	frame=single,
	numbers=left,
	numberstyle=\tiny\color{gray}
}

\title{Problem Set 0 - Solutions}
\author{CSC263 - Data Structures and Analysis}
\date{January 15, 2026}

\begin{document}
\maketitle 

\section*{Problem 1: Runtime Analysis of 0-1 Sorting Algorithm [19 points]}

\subsection*{Algorithm Description}

The provided pseudocode implements a sorting algorithm for lists containing only 0s and 1s:

\begin{algorithmic}
	\State $n\gets$ length of $L$
	\While{true}
	\For{$i$ from 1 to $n$}
	\If{$L[i] = 1$}
	\State break
	\EndIf
	\EndFor
	\For{$j$ from $n$ to 1}
	\If{$L[j] = 0$}
	\State break
	\EndIf
	\EndFor
	\If{$j>i$}
	\State swap $L[i],L[j]$
	\Else \State break
	\EndIf
	\EndWhile
\end{algorithmic}

\subsection*{Part (a): High-Level Description [2 points]}

\textbf{Solution:}

The algorithm repeatedly finds the leftmost 1 and the rightmost 0, swapping them if they are out of order. It terminates when all 0s are before all 1s (i.e., when the leftmost 1 is to the right of the rightmost 0).

\subsection*{Part (b): Runtime Analysis [17 points]}

For a list of length $2n$ containing exactly $n$ zeros and $n$ ones:

\begin{center}
\begin{tabular}{|c|c|c|c|}
	\hline
	& $O$ & $\Omega$ & $\Theta$ \\ \hline
	best-case & $O(n)$ & $\Omega(n)$ & $\Theta(n)$ \\ \hline
	worst-case & $O(n^2)$ & $\Omega(n^2)$ & $\Theta(n^2)$ \\ \hline
	average-case & $O(n^2)$ & $\Omega(n^2)$ & $\Theta(n^2)$ \\ \hline
\end{tabular}
\end{center}

\textbf{Justification:}

\paragraph{Best-Case: $\Theta(n)$}

The best case occurs when the list is already sorted (all 0s before all 1s). For example: $[0,0,\ldots,0,1,1,\ldots,1]$.

In this case:
\begin{itemize}
	\item The first for-loop scans through all $n$ zeros before finding the first 1 at position $n+1$, taking $\Theta(n)$ time
	\item The second for-loop scans from position $2n$ down to $n+1$ (all 1s) before finding the last 0 at position $n$, taking $\Theta(n)$ time
	\item Since $j = n < i = n+1$, the condition $j > i$ fails, and the algorithm terminates
	\item Total: $\Theta(n)$ operations in a single pass
\end{itemize}

\paragraph{Worst-Case: $\Theta(n^2)$}

The worst case occurs when all 1s precede all 0s, requiring the maximum number of swaps. For example: $[1,1,\ldots,1,0,0,\ldots,0]$.

Analysis:
\begin{itemize}
	\item The algorithm performs exactly $n$ swaps (each swap moves one 1 to its correct position in the right half and one 0 to its correct position in the left half)
	\item In iteration $k$ (for $k = 1, 2, \ldots, n$), the array already has $k-1$ zeros at the beginning and $k-1$ ones at the end (from previous swaps)
	\item The first for-loop must scan past the $k-1$ zeros to find the first 1 at position $k$. Cost: $\Theta(k)$
	\item The second for-loop must scan past the $k-1$ ones at the end to find the first 0 at position $2n-k+1$. Cost: $\Theta(k)$
	\item Total cost per iteration: $\Theta(k)$
\end{itemize}

The total runtime is the sum of these increasing costs:
\[
T(n) = \sum_{k=1}^{n} \Theta(k) = \Theta\left(\sum_{k=1}^{n} k\right) = \Theta\left(\frac{n(n+1)}{2}\right) = \Theta(n^2)
\]

Concrete example: For $[1,1,1,0,0,0]$ (where $n=3$):
\begin{itemize}
	\item Iteration 1: Scan to position 1 (1 step) + scan from position 6 (1 step, breaks immediately at 0), swap $L[1]$ and $L[6]$ $\to$ $[0,1,1,0,0,1]$
	\item Iteration 2: Scan to position 2 (2 steps) + scan from position 5 (2 steps, scans past one 1), swap $L[2]$ and $L[5]$ $\to$ $[0,0,1,0,1,1]$
	\item Iteration 3: Scan to position 3 (3 steps) + scan from position 4 (3 steps, scans past two 1s), swap $L[3]$ and $L[4]$ $\to$ $[0,0,0,1,1,1]$
	\item Iteration 4: Scan to position 4 (4 steps) + scan from position 3 (4 steps), check fails, terminate
	\item Total: $(1+1) + (2+2) + (3+3) + (4+4) = 20 = \Theta(n^2)$ operations
\end{itemize}

\paragraph{Average-Case: $\Theta(n^2)$}

For the average case over all possible arrangements of $n$ zeros and $n$ ones:

In a random permutation of $n$ zeros and $n$ ones, we expect approximately $\Theta(n)$ elements to be out of place, requiring $\Theta(n)$ swaps.

Crucially, the cost of finding the next elements to swap \textbf{increases} as the algorithm progresses:
\begin{itemize}
	\item In iteration $k$, the first $k-1$ zeros and the last $k-1$ ones are already in their correct positions
	\item The pointers must scan past these sorted sections to find the next targets
	\item Therefore, the $k$-th iteration performs $\Theta(k)$ comparisons
\end{itemize}

The total work is the sum of these increasing costs:
\[
T(n) = \sum_{k=1}^{n} \Theta(k) = \Theta\left(\sum_{k=1}^{n} k\right) = \Theta\left(\frac{n(n+1)}{2}\right) = \Theta(n^2)
\]

This demonstrates that the runtime is quadratic not because every iteration costs $\Theta(n)$, but because the cost per iteration grows linearly from $\Theta(1)$ to $\Theta(n)$, and these costs sum to $\Theta(n^2)$.

\subsection*{Bonus Part: Improved Implementation [1 point]}

A better algorithm uses the two-pointer technique:

\begin{algorithmic}
	\State $i \gets 1$
	\State $j \gets n$
	\While{$i < j$}
		\While{$i < j$ and $L[i] = 0$}
			\State $i \gets i + 1$
		\EndWhile
		\While{$i < j$ and $L[j] = 1$}
			\State $j \gets j - 1$
		\EndWhile
		\If{$i < j$}
			\State swap $L[i], L[j]$
			\State $i \gets i + 1$
			\State $j \gets j - 1$
		\EndIf
	\EndWhile
\end{algorithmic}

\textbf{Runtime:} $\Theta(n)$ in all cases (best, worst, and average).

Each element is examined at most once because the pointers only move inward and never backtrack. This gives $\Theta(n)$ worst-case and average-case runtime, which is optimal since we must examine each element at least once.

\newpage

\section*{Problem 2: String Concatenation Runtime [10 points]}

\subsection*{Given Code:}

\begin{lstlisting}
def list_of_numbers(num):
    n = int(num)
    out = ""
    for i in range(n):
        out += str(i+1) + ","
    return out
\end{lstlisting}

\subsection*{Solution:}

\textbf{Runtime: $\Theta(n^2)$}

\paragraph{Explanation:}

In Python, strings are \textit{immutable}. This means that the concatenation operation \texttt{out += str(i+1) + ","} does not modify the existing string. Instead, it:

\begin{enumerate}
	\item Creates a new string object
	\item Copies all characters from the old \texttt{out} string
	\item Appends the new characters
	\item Reassigns \texttt{out} to point to this new string
\end{enumerate}

\paragraph{Detailed Analysis:}

At iteration $i$ (where $i = 0, 1, \ldots, n-1$):
\begin{itemize}
	\item The current length of \texttt{out} is approximately proportional to $i$ (specifically, it's roughly $2i$ characters, accounting for numbers and commas)
	\item The concatenation operation takes $\Theta(i)$ time to copy the existing string
	\item Adding the new number takes $\Theta(\log i)$ time (for converting the number to a string)
	\item Total time for iteration $i$: $\Theta(i)$
\end{itemize}

Summing over all iterations:
\[
T(n) = \sum_{i=1}^{n} \Theta(i) = \Theta\left(\sum_{i=1}^{n} i\right) = \Theta\left(\frac{n(n+1)}{2}\right) = \Theta(n^2)
\]

\paragraph{Why This Is Tricky:}

At first glance, the code appears to be $\Theta(n)$ since there's only one loop. However, the hidden cost of string concatenation in Python makes this quadratic. Each \texttt{+=} operation on strings is $O(length)$, not $O(1)$.

\paragraph{Efficient Alternative:}

To achieve $\Theta(n)$ runtime, use a list to accumulate strings and join them once:

\begin{lstlisting}
def list_of_numbers(num):
    n = int(num)
    parts = []
    for i in range(n):
        parts.append(str(i+1))
    return ",".join(parts)
\end{lstlisting}

Or more concisely:

\begin{lstlisting}
def list_of_numbers(num):
    n = int(num)
    return ",".join(str(i+1) for i in range(n))
\end{lstlisting}

Both alternatives run in $\Theta(n)$ time because:
\begin{itemize}
	\item Appending to a list is amortized $O(1)$
	\item The \texttt{join} operation concatenates all strings in a single pass, taking $\Theta(total\_length)$ time, which is $\Theta(n)$ for this problem
\end{itemize}

\end{document}
